{"meta":{"title":"随笔","subtitle":"Falost的档案室","description":"记录本人一生中发生的有趣的并愿意记录下来的人与事！","author":"falost","url":"https://falost.cc/archives"},"pages":[{"title":"about","date":"2018-08-25T14:06:49.000Z","updated":"2019-09-19T08:07:20.829Z","comments":true,"path":"about/index.html","permalink":"https://falost.cc/archives/about/index.html","excerpt":"","text":"您好：欢迎来到我的写作小屋，这里所有的文章都是只做存档所留，如需浏览或交流，请访问我的个人主页进行访问查看！地址：https://falost.cc"},{"title":"友情链接","date":"2018-08-25T18:17:39.000Z","updated":"2018-08-25T18:45:13.122Z","comments":true,"path":"links/index.html","permalink":"https://falost.cc/archives/links/index.html","excerpt":"","text":""},{"title":"标签云","date":"2018-08-26T03:38:43.000Z","updated":"2018-08-26T03:39:36.061Z","comments":true,"path":"tags/index.html","permalink":"https://falost.cc/archives/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"利用Node Puppeteer 来搭建多端统一的海报渲染服务","slug":"利用Node-Puppeteer-来搭建多端统一的海报渲染服务","date":"2019-09-19T07:58:00.000Z","updated":"2019-09-19T08:02:05.987Z","comments":true,"path":"posts/57243847.html","link":"","permalink":"https://falost.cc/archives/posts/57243847.html","excerpt":"","text":"作者：falost原文地址：https://falost.cc/article/5d74e54f8457894be1bc3b45如需转载请注明来源！缘起在朋友圈，你可能会见过有很多带着个人信息或者二维码的绚丽的海报图片，看起来很高大上的样子。在很早之前，我有过了解的是，这些海报图片都是由 UI 设计师，进行人肉设计出来的，非常考验设计师的忍耐力。再到后来，随着 web 技术的发展，出现了由前端来生成一张又一张的海报图片，这样 UI 设计师只需要设计一张模版图片，剩余的交给前端来完成即可，大大的减轻了 UI 小姐姐们苦力活(滑稽笑)。虽然，UI 小姐姐的活减轻了，但是前端（包含移动端）小哥哥的活就加重了，还面临着很多头疼的问题，比如：生成的图片清晰度不够、手机兼容问题导致生成失败、资源跨域问题导致生成失败、web 端和移动端生成的图片不一样等等问题。我们了解下前端是如何生成海报图片的呢？其实前端是通过 HTML5 新增加的 canvas API 来绘制的，但是 canvas 绘制会有很多的痛点：上手门槛比较高，需要掌握 canvas API；代码可读性比较差、调试复杂；代码可复用低，每个端需要重新编码；无缓存、同一张相同图片会多次绘制，用户体验差；如果有远程图片，可能会引起跨域问题，导致绘制失败等等问题。针对这些问题，社区出现了一个开源库（html2canvas），通过编写 HTML 页面来生成图片，有效解决了大部分问题，但是图片跨域、缓存、代码复用问题，还是无法解决。针对这些问题，社区提出了使用服务端来完成海报图片渲染，就有可能彻底解决这些问题。我们该如何通过服务端来渲染这个海报呢？在小程序社区，有赞商城前端团队成员提出基于 Puppeteer 来实现公共海报渲染服务，使用方只需传入海报图片的html，海报渲染服务绘制一张对应的图片作为返回结果，解决了canvas绘制的各种痛点问题。那么，我今天就来体验下快感吧。在这之前，我们先来了解下！Puppeteer 是什么puppeteer 是一个Chrome官方出品的headless Chrome node库。它提供了一系列的API, 可以在无UI的情况下调用Chrome的功能, 适用于爬虫、自动化处理等各种场景等。Puppeteer 能做什么根据官网上描述，Puppeteer几乎能实现你能在浏览器上做的任何事情，比如:1、生成页面截图和 PDF；2、自动化表单提交、UI 测试、键盘输入等；3、创建一个最新的自动化测试环境。使用最新的 JavaScript ；4、和浏览器功能，可以直接在最新版本的 Chrome 中运行测试；5、捕获站点的时间线跟踪，以帮助诊断性能问题；6、爬取 SPA 页面并进行预渲染(即’SSR’)。本文的渲染服务将会使用它的截图功能，来实现图片生成。代码实现接下来，就让我们简单的看看如何代码实现吧！首先，需要先初始化一个 npm 项目，并且安装响应的模块，这里就不一一说明了。12npm initnpm install puppeteer koa crypto --save这里，我们安装了三个模块：puppeteer 我们今天的关键性模块、koa 快速搭建一个 web 服务、crypto 通过加密内容字符串来生成唯一标识符。另外，我的 node 版本是 10.11 的，所以使用了很多新语法。app.js1234567891011121314151617181920/* * @Descripttion: 入口文件 * @version: 1.0.0 * @Author: falost * @Date: 2019-08-27 10:54:32 * @LastEditors: falost * @LastEditTime: 2019-09-08 18:20:41 */const SnapshotController = require('./libs/SnapshotController')const Koa = require('koa')const controller = new SnapshotController()const app = new Koa()app.use(async ctx =&gt; &#123; return await controller.postSnapshotJson(ctx)&#125;)app.listen(3000)/libs/SnapshotController.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/* * @Descripttion: 调取 puppenter 来生成接收到的html 数据生成图片 * @version: 1.0.0 * @Author: falost * @Date: 2019-08-27 09:55:52 * @LastEditors: falost * @LastEditTime: 2019-09-08 18:20:56 */const crypto = require('crypto');const PuppenteerHelper = require('./PuppenteerHelper');const oneDay = 24 * 60 * 60;class SnapshotController &#123; /** * 截图接口 * @param &#123;Object&#125; ctx 上下文 */ async postSnapshotJson(ctx) &#123; const result = await this.handleSnapshot() ctx.body = &#123;code: 10000, message: 'ok', result&#125; &#125; async handleSnapshot() &#123; const &#123; ctx &#125; = this const &#123; html &#125; = ctx.request.body // html 是我们将要生成的海报图片的 HTML 实现代码字符串 // 根据 html 做 sha256 的哈希作为 Redis Key const htmlRedisKey = crypto.createHash('sha256').update(html).digest('hex'); try &#123; // 首先看海报是否有绘制过的 let result = await this.findImageFromCache(htmlRedisKey); // 获取缓存失败 if (!result) &#123; result = await this.generateSnapshot(htmlRedisKey); &#125; return result; &#125; catch (error) &#123; ctx.status = 500; return ctx.throw(500, error.message); &#125; &#125; /** * 判断kv中是否有缓存 * @param &#123;String&#125; htmlRedisKey kv存储的key */ async findImageFromCache(htmlRedisKey) &#123; return false &#125; /** * 生成截图 * @param &#123;String&#125; htmlRedisKey kv存储的key */ async generateSnapshot(htmlRedisKey) &#123; const &#123; ctx &#125; = this const &#123; html, width = 375, height = 667, quality = 80, ratio = 2, type: imageType = 'jpeg', &#125; = ctx.request.body; if (!html) &#123; return 'html 不能为空' &#125; let imgBuffer; try &#123; imgBuffer = await PuppenteerHelper.createImg(&#123; html, width, height, quality, ratio, imageType, fileType: 'path', htmlRedisKey &#125;); &#125; catch (err) &#123; // logger console.log(err) &#125; let imgUrl; try &#123; imgUrl = await this.uploadImage(imgBuffer); // 将海报图片路径存在 Redis 里 await ctx.kvdsClient.setex(htmlRedisKey, oneDay, imgUrl); &#125; catch (err) &#123; &#125; return &#123; img: imgUrl || '' &#125; &#125; /** * 上传图片到 CDN 服务 * @param &#123;Buffer&#125; imgBuffer 图片buffer */ async uploadImage(imgBuffer) &#123; // upload image to cdn and return cdn url &#125;&#125;module.exports = SnapshotController./libs/PuppenteerHelper.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* * @Descripttion: 创建生成图片类 * @version: 1.0.0 * @Author: falost * @Date: 2019-08-27 11:43:41 * @LastEditors: falost * @LastEditTime: 2019-09-08 18:20:51 */const puppeteer = require('puppeteer')const &#123; mkdirsSync, formatNumber &#125; = require('../utils/utils')class PuppenteerHelper &#123; async createImg(params) &#123; const browser = await puppeteer.launch(&#123; headless: false, // 默认为 true 打开浏览器，设置 false 不打开 &#125;) const date = new Date() const path = `static/upload/$&#123;date.getFullYear()&#125;/$&#123;formatNumber(date.getMonth() + 1)&#125;` mkdirsSync(path) // 通过创建浏览器标签来打开 const page = await browser.newPage() // 设置视窗大小 await page.setViewport(&#123; width: params.width, height: params.height, deviceScaleFactor: params.ratio &#125;) // 设置需要截图的html内容 await page.setContent(params.html) await this.waitForNetworkIdle(page, 50) let filePath // 根据 type 返回不同的类型 一种图片路径、一种 base64 if (params.fileType === 'path') &#123; filePath = `$&#123;path&#125;/$&#123;params.htmlRedisKey&#125;.$&#123;params.imageType&#125;` await page.screenshot(&#123; path: filePath, fullPage: false, omitBackground: true &#125;) &#125; else &#123; filePath = await page.screenshot(&#123; fullPage: false, omitBackground: true, encoding: 'base64' &#125;) &#125; browser.close() return filePath &#125; // 等待HTML 页面资源加载完成 waitForNetworkIdle(page, timeout, maxInflightRequests = 0) &#123; page.on('request', onRequestStarted); page.on('requestfinished', onRequestFinished); page.on('requestfailed', onRequestFinished); let inflight = 0; let fulfill; let promise = new Promise(x =&gt; fulfill = x); let timeoutId = setTimeout(onTimeoutDone, timeout); return promise; function onTimeoutDone() &#123; page.removeListener('request', onRequestStarted); page.removeListener('requestfinished', onRequestFinished); page.removeListener('requestfailed', onRequestFinished); fulfill(); &#125; function onRequestStarted() &#123; ++inflight; if (inflight &gt; maxInflightRequests) clearTimeout(timeoutId); &#125; function onRequestFinished() &#123; if (inflight === 0) return; --inflight; if (inflight === maxInflightRequests) timeoutId = setTimeout(onTimeoutDone, timeout); &#125; &#125;&#125;module.exports = new PuppenteerHelper()../utils/utils.js123456789101112131415161718192021222324252627282930/* * @Descripttion: 工具类库 * @version: * @Author: falost * @Date: 2019-08-27 14:10:16 * @LastEditors: falost * @LastEditTime: 2019-08-27 14:15:52 */const fs = require('fs')const path = require('path')const mkdirsSync = (dirname) =&gt; &#123; if (fs.existsSync(dirname)) &#123; return true; &#125; else &#123; if (mkdirsSync(path.dirname(dirname))) &#123; fs.mkdirSync(dirname); return true; &#125; &#125;&#125;const formatNumber = function (n) &#123; n = n.toString() return n[1] ? n : '0' + n&#125;module.exports = &#123; mkdirsSync, formatNumber&#125;效果到这里，简单的代码实现步骤，现已完成，接下来我们看看最后生成的效果图吧！结语如果你想要用于生产环境，那么你还需要做一些其他个工作，这样才能保证他能更好的产出。当然这里面也有些坑，还需要我们去完成填坑的。git 仓库地址：https://github.com/falost/node-puppeteer-poster如果你想了解更多关于 puppeteer 的使用， 可以查询官方仓库说明文档：https://github.com/GoogleChrome/puppeteer非常感谢您的耐心阅读！文中如有不对之处，欢迎留言指教！","categories":[{"name":"tech","slug":"tech","permalink":"https://falost.cc/archives/categories/tech/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://falost.cc/archives/tags/node-js/"},{"name":"puppeteer","slug":"puppeteer","permalink":"https://falost.cc/archives/tags/puppeteer/"},{"name":"海报服务","slug":"海报服务","permalink":"https://falost.cc/archives/tags/海报服务/"}]},{"title":"Javascript 中的 Date 对象引发的血案","slug":"Javascript-中的-Date-对象引发的血案","date":"2019-09-19T07:56:00.000Z","updated":"2019-09-19T08:02:47.327Z","comments":true,"path":"posts/a1bafcf4.html","link":"","permalink":"https://falost.cc/archives/posts/a1bafcf4.html","excerpt":"","text":"作者：falost原文地址：https://falost.cc/article/5d62760b8d183230607f417a如需转载请注明来源！本文无任何技术含量，只能算是科普文吧！缘由在工作中，因和后端配合的时候，后端返回的时间对象不是前端所需要的标准时间，而产生的一系列问题反思！Date 对象Date对象大家众所周知他是干什么用的？怎么用？这些都不是问题，但是在每个语言种类和宿主环境不同的情况下，就会产生些奇奇怪怪的问题，比如：前端通过接口拿到了一个Java后端返回的时间对象（2019-08-25 18:00:00），然后经过 js 处理展示不同的格式（如：2019/08/25、现在、08/25 18:00）前端开发的小伙子拿到这个值之后就是一顿操作：1234567891011121314151617181920212223242526272829303132333435const formatTime = function (date, format = '', conn = '-') &#123; date = new Date(date) let year = date.getFullYear() let month = date.getMonth() + 1 let day = date.getDate() let hour = date.getHours() let minute = date.getMinutes() let second = date.getSeconds() switch (format) &#123; case 'YY-MM-DD': return [year, month, day].map(formatNumber).join(conn) case 'YY-MM-DD HH:mm': return [year, month, day].map(formatNumber).join(conn) + ' ' + [hour, minute].map(formatNumber).join(':') case 'YY-MM-DD HH:mm:ss': return [year, month, day].map(formatNumber).join(conn) + ' ' + [hour, minute, second].map(formatNumber).join(':') case 'MM-DD HH:mm': return [month, day].map(formatNumber).join(conn) + ' ' + [hour, minute].map(formatNumber).join(':') case 'MM-DD': return [month, day].map(formatNumber).join(conn) case 'YYMMDD': return year + '年' + formatNumber(month) + '月' + formatNumber(day) + '日' case 'MMDD': return formatNumber(month) + '月' + formatNumber(day) + '日' default: return [year, month, day].map(formatNumber).join(conn) + ' ' + [hour, minute, second].map(formatNumber).join(':') &#125;&#125;const formatNumber = function (n) &#123; n = n.toString() return n[1] ? n : '0' + n&#125;console.log(formatTime('2019-08-25 18:00:00', 'MM-DD HH:mm', '/')) // 08/25 18:00执行之后没有毛病，我们如愿的拿到了想要的效果 08/25 18:00，有同学肯定会说，这么简单，有啥问题呢？在谷歌这些通用浏览器中，好像的确没啥问题，都是正常情况，但是拿到了 Safari 浏览器之后，傻眼了，什么情况？怎么得到的是一个（&quot;NaN/NaN NaN:NaN&quot;）字符串出来了？我的时间呢？时区我们先来了解下时区由于世界各国家与地区经度不同，地方时也有所不同，因此会划分为不同的时区。正式的时区划分，其中包括24个时区，每一时区由一个英文字母表示。每隔经度15°划分一个时区，有一个例外，每个时区有一条中央子午线；例如，GMT属于“z”区，因此其时间后通常添加后缀“Z”（口语中用后缀“Zulu”）。这是来自百度百科关于时区的一段说明，那么最基本的解释就是：是地球上的区域使用同一个时间。然后我们再来看看 JavaScript 中对于时间的描述创建一个 JavaScript Date 实例，该实例呈现时间中的某个时刻。Date 对象则基于 Unix Time Stamp，即自1970年1月1日（UTC）起经过的毫秒数。也就是说，在 JavaScript 中Date对象是基于 UTC 时间标准来衡量时间的。那么我们再来看看什么是 UTC？协调世界时，又称世界统一时间、世界标准时间、国际协调时间。由于英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称UTC。还是来百度百科的说明，看到 UTC 那么肯定会想到 GMT，其实UTC与格林威治平均时(GMT, Greenwich Mean Time)一样，都是英国伦敦的本地时相同，所以在 JavaScript 中 UTC == GMT。发现问题其实说了这么多文献，就是说明一件事—时区，那为什么要说明时区呢？因为我们这里就是出现时区的问题上，导致 Safari 的 JS 引擎没有识别到当前时间值时区的划分，导致在 new Date() 时候出现了错误,如：1new Date(&apos;2019-08-25 18:00:00&apos;) // Invalid DateOK，到这里这里之后，我们在回归刚才的问题上：1、发现了在 Safari 浏览器中不能识别类似时间（&#39;2019-08-25 18:00:00&#39;）的，导致出现了 NaN 的情况？2、发现了问题根本原因是因为时间不是 UTC 标准格式（没有时区信息）导致的？3、现在给出问题的解决方案。解决方案既然我们已经知道了出现问题的根本原因，那么就可以对症下药了：1、后端对时间进行重新转义，将时间转换为 UTC 标准时间格式，如：&#39;2019-08-25T18:00:00+08:00&#39;2、后端将时间转换成时间戳形式，如：1566727200000这两点是后端处理的方法，前端处理方法，比较复杂，需要将时间字符串通过正则替换为标准时间，这里就不多说了，因为这种方法治标不治本。当然，如果你有什么好的处理方法，欢迎留言给我！总结另外，这里也提到了一个能高效解决问题的方案：1、发现出现了什么问题？2、发生这个问题的根本原因是什么？3、在提出解决方案。我们解决问题，不能只解决表象问题，要找问题的根本原因在哪里，然后再着手解决处理，这样我们才能真正的解决问题。不要一发现问题，就想着怎么去处理，那么有可能就会出现很多未知问题。找代码的 bug 如果不按照这种思维去处理的话，我相信你的代码就像下面一样：好了，本文就啰嗦到这里了，文中如有不对之处，望多多指教！祝大家新的一周愉快！参考文献1、时区：https://baike.baidu.com/item/%E6%97%B6%E5%8C%BA/4911222、协调世界时：https://baike.baidu.com/item/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6/7876593、北京时间：http://www.beijing-time.org/time15.asp4、JavaScript 内置 Date 对象：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date","categories":[{"name":"tech","slug":"tech","permalink":"https://falost.cc/archives/categories/tech/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://falost.cc/archives/tags/javascript/"},{"name":"date","slug":"date","permalink":"https://falost.cc/archives/tags/date/"}]},{"title":"优雅的使用 rem 进行移动端布局开发","slug":"优雅的使用-rem-进行移动端布局开发","date":"2019-09-19T07:48:00.000Z","updated":"2019-09-19T07:55:21.337Z","comments":true,"path":"posts/a2ff3f3.html","link":"","permalink":"https://falost.cc/archives/posts/a2ff3f3.html","excerpt":"","text":"作者：falost原文地址：https://falost.cc/article/5d593827f3ad2c3fe3bc9ad9缘起在工作中，移动APP端的同学问我，在移动web端中是如何去做不同的屏幕大小所展示的效果和设计图都是一致的？我们在遇到这种问题的时候，脑海中第一反应，应该是使用哪种布局方案去实现这种效果吧？布局方案先说说布局方案，在前端历史计划中，诞生了几种布局概念，分别是：静态布局流式布局自适应布局响应式布局弹性布局题外话这其中，因 bootstrap 的原因，我们对响应式布局绝对是很熟悉的，它的栅格系统就是使用了响应式布局方案。那么静态布局，也是我们经常使用在 PC 当中，但是随着科技的发展，越来越多的屏幕大小，以至于静态布局再也满足不了我们需求了，这时候自适应布局就出来了，根据不同尺寸和设备切换不同的样式。关于布局概念，本文就不做过多的介绍，切入正题。rem 布局同样相对于 PC 端，有不少的屏幕尺寸需要做兼容处理，那么移动端也是不例外的，而且移动端的机型是比较复杂的，那么就需要一套比较完善的布局方案来支持了。因淘宝的 Flexible 让rem布局火了起来，导致前端圈中出现了很多的 rem 布局方案，我就是 rem 布局方案的崇拜者，那么就来说说 rem 布局。rem是什么rem（font size of the root element）是指相对于根元素的字体大小的单位，简单的说它就是一个相对单位。在面试中，我经常会问答 rem 和 em 的区别，得到的答案也是各有千秋，那么，到底该怎么去理解两个单位？其实 em（font size of the element）也是一个相对单位。只是 em 相对于父元素的字体大小的单位。rem 是相对于根元素的字体大小的单位。案例刚才我们说到了淘宝引发的潮流，那么我们在说几个：亚马逊、携程、京东、当当这些网站都有使用了的 rem 的布局方案。rem + flex 布局方案rem 的布局，大家都知道就是操作 html 根元素的字体大小来实现的不同尺寸单位的换算。这里重点的就是根元素字体大小的设置，之前我所使用的是通过媒体查询来设置不同的大小，比如：1234567891011121314151617@media screen and (max-width: 414px) &#123; html &#123; font-size: 18px &#125;&#125;@media screen and (max-width: 375px) &#123; html &#123; font-size: 16px &#125;&#125;@media screen and (max-width: 320px) &#123; html &#123; font-size: 12px &#125;&#125;因视窗单位的设备支持度越来越好，所以就有了123html&#123; font-size: calc(100vw/7.5);&#125;再配合 js 处理不支持视窗单位的设备1document.documentElement.style.fontSize = window.innerWidth/7.5 + 'px'可能这里，就会有朋友问我，为什么这里要除于 7.5 呢?答：这里是因为很多设计稿都是基于 iPhone6 来设计的，一般都是 750px（2 倍图，iPhone6 的设备宽度为 375px）所以除于 7.5 是为了在 iPhone6 设备下让 1rem 等于 100px，当然这个可以根据你设计稿来定。如何在 css 中根据设计图的 px 尺寸来缓存 rem 尺寸呢？这里，我将使用 scss 的便捷来处理单位的换算：123456789@function px2rem($px, $base-font-size: 50px) &#123; @if (unitless($px)) &#123; @warn \"Assuming #&#123;$px&#125; to be in pixels, attempting to convert it into pixels for you\"; @return px2rem($px + 0px); // That may fail. &#125; @else if (unit($px) == rem) &#123; @return $px; &#125; @return ($px / $base-font-size) * 1rem;&#125;因为这里的设计图使用的是 1 倍图，所以$base-font-size为 100px / 2 = 50px123div &#123; width: px2rem(100px);&#125;换算结果123div &#123; width: 2rem;&#125;到这里，我们的 rem 布局使用就已经完成了，那么在实际工作当中，肯定一个 rem 是解决不了所有的布局需求的，那么这里我们在配合着 flex 布局，就能解决一大半的布局问题了，关于 flex 布局，我将会在下文中分享！最后，感谢各位的耐心阅读，如果文中有不对或不全之处，欢迎留言指教！在最后，如果感觉本文不错或对你有帮助，不妨点个赞呗！","categories":[{"name":"tech","slug":"tech","permalink":"https://falost.cc/archives/categories/tech/"}],"tags":[{"name":"css","slug":"css","permalink":"https://falost.cc/archives/tags/css/"}]},{"title":"vsCode 自定义代码片段(Snippet)中可使用的变量说明","slug":"vsCode_Snippet","date":"2018-08-25T18:22:00.000Z","updated":"2019-09-19T07:55:59.178Z","comments":true,"path":"posts/53a167dc.html","link":"","permalink":"https://falost.cc/archives/posts/53a167dc.html","excerpt":"","text":"Variables：变量使用$name或${name:default}可以插入变量的值。当变量未赋值时（如），将插入其缺省值或空字符串。 当varibale未知（即，其名称未定义）时，将插入变量的名称，并将其转换为「Placeholder」。可以使用的「Variable」如下：TM_SELECTED_TEXT：当前选定的文本或空字符串；注：选定后通过在命令窗口点选「插入代码片段」插入。TM_CURRENT_LINE：当前行的内容；TM_CURRENT_WORD：光标所处单词或空字符串注：所谓光标一般为文本输入处那条闪来闪去的竖线，该项可定制。单词使用 VSCode 选词（Word Wrap）器选择。你最好只用它选择英文单词，因为这个选择器明显没有针对宽字符优化过，它甚至无法识别宽字符的标点符号。TM_LINE_INDEX：行号（从零开始）；TM_LINE_NUMBER：行号（从一开始）；TM_FILENAME：当前文档的文件名；TM_FILENAME_BASE：当前文档的文件名（不含后缀名）；TM_DIRECTORY：当前文档所在目录；TM_FILEPATH：当前文档的完整文件路径；CLIPBOARD：当前剪贴板中内容。CURRENT_YEAR: 当前年份；CURRENT_YEAR_SHORT: 当前年份的后两位；CURRENT_MONTH: 格式化为两位数字的当前月份，如 02；CURRENT_MONTH_NAME: 当前月份的全称，如 July；CURRENT_MONTH_NAME_SHORT: 当前月份的简称，如 Jul；CURRENT_DATE: 当天月份第几天；CURRENT_DAY_NAME: 当天周几，如 Monday；CURRENT_DAY_NAME_SHORT: 当天周几的简称，如 Mon；CURRENT_HOUR: 当前小时（24 小时制）；CURRENT_MINUTE: 当前分钟；CURRENT_SECOND: 当前秒数。注：这些都是变量名，不是宏，在实际使用的时要加上 $ 符。使用案例代码：123456789101112131415&quot;Add multi-line comments&quot;: &#123; &quot;scope&quot;: &quot;javascript,typescript,vue&quot;, &quot;prefix&quot;: &quot;funz&quot;, &quot;body&quot;: [ &quot;/**&quot;, &quot; * @name $&#123;1&#125;&quot;, &quot; * @desc $2&quot;, &quot; * @author Falost&quot;, &quot; * @time $CURRENT_YEAR年$CURRENT_MONTH月$CURRENT_DATE日 $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND $CURRENT_DAY_NAME&quot;, &quot; * @param &#123;$&#123;4|Object,String,Number,Array,Function|&#125;&#125; &#123;$5&#125;&quot;, &quot; * @return $&#123;6: &#123;*&#125;&#125;&quot;, &quot; */$10&quot; ], &quot;description&quot;: &quot;Add multi-line comments&quot;&#125;使用效果代码：12345678/** * @name * @desc * @author Falost * @time 2019年04月20日 14:58:47 星期六 * @param &#123;Object&#125; &#123;&#125; * @return &#123;*&#125; */参考资料：https://code.visualstudio.com/docs/editor/userdefinedsnippets","categories":[{"name":"tech","slug":"tech","permalink":"https://falost.cc/archives/categories/tech/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://falost.cc/archives/tags/vscode/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-25T09:20:00.000Z","updated":"2019-09-19T07:57:50.649Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"https://falost.cc/archives/posts/4a17b156.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","categories":[{"name":"life","slug":"life","permalink":"https://falost.cc/archives/categories/life/"}],"tags":[{"name":"hello","slug":"hello","permalink":"https://falost.cc/archives/tags/hello/"},{"name":"frist","slug":"frist","permalink":"https://falost.cc/archives/tags/frist/"}]}]}